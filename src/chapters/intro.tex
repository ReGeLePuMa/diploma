\chapter{Introduction}
\label{chapter:intro}

\textit{“But ... it works on my machine...”} is a phrase no developer wants to hear.
It is a phrase that highlights both the frustration of software engineers and the complexity of
the software development life cycle. The most common cause for this issue arising lies in the
mismatch between the developer's local environment and the production environment where the code is run
\cite{but-it-works-on-my-machine}. On traditional deployments on a physical server or virtual machine, it is
up to the developer to ensure that all the necessary configurations are met for the application to run,
which can be a tedious process, especially when the the number of dependencies is high or when we want to 
upgrade to a newer version.

The solution? ... Using containers. Containers are software that package up code,
runtime, libraries, config files, everything needed for an application to run \cite{what-are-containers} which 
can then be executed across different machines without additional setup. This, alongside
faster boot times, lower resource usage and ease of scale, especially when coupled with orchestration tools like Kubernetes, made containers 
grow in popularity, even surpassing virtual machines in some cases \cite{containers-usage-statistics}.

However, the comparison with virtual machines, where containers are usually much better, often paints the picture that
these metrics are irrelevant when it pertains to them, one such metric being size of the container itself. This is not true.
The size of the container is directly proportional to the number of binaries and packages that are installed and as such
reducing the size has the following benefits \cite{why-keep-containers-small}:
\begin{itemize}
    \item \textbf{Security} - smaller the size, smaller the attack surface a hacker has to work with
    \item \textbf{Performance and Efficiency} - smaller images are faster to deploy and, in general, use fewer system resources
    \item \textbf{Maintainability} - smaller images have fewer dependencies, making it easer to maintain and update them
\end{itemize}

As such, the goal of my project is to create a tool than can strip a container of all its unnecessary files and packages,
leaving only the files needed for the application to run properly and export it as a \textit{Dockerfile}, the recipe used to create the container.
 